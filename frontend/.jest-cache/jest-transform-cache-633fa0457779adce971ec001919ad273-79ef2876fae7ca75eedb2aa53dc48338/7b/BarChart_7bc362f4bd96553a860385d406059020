0bf157f2fcc76ac6645da15ab45cb92e
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BarChart: function() {
        return BarChart;
    },
    default: function() {
        return _default;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _useChartTheme = require("../../hooks/useChartTheme");
const _chartValidation = require("../../lib/chartValidation");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const BarChart = /*#__PURE__*/ _react.default.memo(function BarChart(props) {
    const { getColor } = (0, _useChartTheme.useChartTheme)();
    // Validate and sanitize props
    const { data: rawData, height = 120, showLabels = true, showValues = false, animated = true, className = '', barSpacing = 8 } = (0, _react.useMemo)(()=>{
        return _chartValidation.validationMonitor.measureValidation('BarChart', ()=>{
            try {
                const sanitizedProps = (0, _chartValidation.sanitizeChartProps)(props);
                const sanitizedData = (0, _chartValidation.sanitizeBarChartData)(props.data);
                return {
                    ...props,
                    ...sanitizedProps,
                    data: sanitizedData
                };
            } catch (error) {
                if (error instanceof _chartValidation.ChartValidationError) {
                    console.error('BarChart validation error:', error);
                    // Return safe defaults
                    return {
                        ...props,
                        data: [],
                        height: 120,
                        showLabels: true,
                        showValues: false,
                        animated: true,
                        className: '',
                        barSpacing: 8
                    };
                }
                throw error;
            }
        });
    }, [
        props
    ]);
    const data = rawData;
    if (!data || data.length === 0) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
            className: `w-full bg-gray-100 dark:bg-invary-secondary/20 rounded ${className}`,
            style: {
                height
            },
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                className: "flex items-center justify-center h-full text-invary-neutral dark:text-gray-400 text-xs",
                children: "No data"
            })
        });
    }
    const maxValue = Math.max(...data.map((d)=>d.value));
    const labelHeight = showLabels ? 20 : 0;
    const chartHeight = height - labelHeight;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        className: `w-full ${className}`,
        style: {
            height
        },
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
            className: "flex items-end justify-between h-full",
            children: data.map((item, index)=>{
                const barHeight = item.value / maxValue * chartHeight;
                const barColor = item.color || getColor(index);
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                    className: "flex flex-col items-center flex-1",
                    style: {
                        marginRight: index < data.length - 1 ? barSpacing : 0
                    },
                    children: [
                        showValues && /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            className: "text-xs text-invary-neutral dark:text-gray-300 mb-1 font-medium",
                            children: item.value
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            className: "relative w-full flex items-end",
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                className: `w-full rounded-t ${animated ? 'transition-all duration-500 ease-out' : ''}`,
                                style: {
                                    height: barHeight,
                                    backgroundColor: barColor,
                                    backgroundImage: `linear-gradient(to top, ${barColor}, ${barColor}dd)`
                                },
                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                                    className: "absolute inset-0 rounded-t-sm",
                                    style: {
                                        background: 'linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%)'
                                    }
                                })
                            })
                        }),
                        showLabels && /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                            className: "text-xs text-invary-neutral dark:text-gray-400 mt-2 text-center truncate w-full",
                            children: item.label
                        })
                    ]
                }, index);
            })
        })
    });
}, (prevProps, nextProps)=>{
    // Custom comparison for array data
    if (prevProps.data.length !== nextProps.data.length) return false;
    const dataEqual = prevProps.data.every((item, idx)=>{
        const nextItem = nextProps.data[idx];
        return item.label === nextItem.label && item.value === nextItem.value && item.color === nextItem.color;
    });
    return dataEqual && prevProps.height === nextProps.height && prevProps.showLabels === nextProps.showLabels && prevProps.showValues === nextProps.showValues && prevProps.animated === nextProps.animated && prevProps.className === nextProps.className && prevProps.barSpacing === nextProps.barSpacing;
});
const _default = BarChart;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvY29tcG9uZW50cy9jaGFydHMvQmFyQ2hhcnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDaGFydFRoZW1lIH0gZnJvbSAnQC9ob29rcy91c2VDaGFydFRoZW1lJztcbmltcG9ydCB7IFxuICBzYW5pdGl6ZUJhckNoYXJ0RGF0YSwgXG4gIHNhbml0aXplQ2hhcnRQcm9wcywgXG4gIHZhbGlkYXRpb25Nb25pdG9yLFxuICBDaGFydFZhbGlkYXRpb25FcnJvciBcbn0gZnJvbSAnQC9saWIvY2hhcnRWYWxpZGF0aW9uJztcblxuaW50ZXJmYWNlIEJhckNoYXJ0UHJvcHMge1xuICBkYXRhOiBBcnJheTx7IGxhYmVsOiBzdHJpbmc7IHZhbHVlOiBudW1iZXI7IGNvbG9yPzogc3RyaW5nIH0+O1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHNob3dMYWJlbHM/OiBib29sZWFuO1xuICBzaG93VmFsdWVzPzogYm9vbGVhbjtcbiAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGJhclNwYWNpbmc/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBCYXJDaGFydCA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gQmFyQ2hhcnQocHJvcHM6IEJhckNoYXJ0UHJvcHMpIHtcbiAgY29uc3QgeyBnZXRDb2xvciB9ID0gdXNlQ2hhcnRUaGVtZSgpO1xuICBcbiAgLy8gVmFsaWRhdGUgYW5kIHNhbml0aXplIHByb3BzXG4gIGNvbnN0IHtcbiAgICBkYXRhOiByYXdEYXRhLFxuICAgIGhlaWdodCA9IDEyMCxcbiAgICBzaG93TGFiZWxzID0gdHJ1ZSxcbiAgICBzaG93VmFsdWVzID0gZmFsc2UsXG4gICAgYW5pbWF0ZWQgPSB0cnVlLFxuICAgIGNsYXNzTmFtZSA9ICcnLFxuICAgIGJhclNwYWNpbmcgPSA4XG4gIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gdmFsaWRhdGlvbk1vbml0b3IubWVhc3VyZVZhbGlkYXRpb24oJ0JhckNoYXJ0JywgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkUHJvcHMgPSBzYW5pdGl6ZUNoYXJ0UHJvcHMocHJvcHMpO1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gc2FuaXRpemVCYXJDaGFydERhdGEocHJvcHMuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgIC4uLnNhbml0aXplZFByb3BzLFxuICAgICAgICAgIGRhdGE6IHNhbml0aXplZERhdGFcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENoYXJ0VmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignQmFyQ2hhcnQgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgLy8gUmV0dXJuIHNhZmUgZGVmYXVsdHNcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIGhlaWdodDogMTIwLFxuICAgICAgICAgICAgc2hvd0xhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dWYWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgICAgICAgYmFyU3BhY2luZzogOFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtwcm9wc10pO1xuXG4gIGNvbnN0IGRhdGEgPSByYXdEYXRhO1xuICBcbiAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtgdy1mdWxsIGJnLWdyYXktMTAwIGRhcms6YmctaW52YXJ5LXNlY29uZGFyeS8yMCByb3VuZGVkICR7Y2xhc3NOYW1lfWB9IHN0eWxlPXt7IGhlaWdodCB9fT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLWZ1bGwgdGV4dC1pbnZhcnktbmV1dHJhbCBkYXJrOnRleHQtZ3JheS00MDAgdGV4dC14c1wiPlxuICAgICAgICAgIE5vIGRhdGFcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWF4VmFsdWUgPSBNYXRoLm1heCguLi5kYXRhLm1hcChkID0+IGQudmFsdWUpKTtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBzaG93TGFiZWxzID8gMjAgOiAwO1xuICBjb25zdCBjaGFydEhlaWdodCA9IGhlaWdodCAtIGxhYmVsSGVpZ2h0O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2B3LWZ1bGwgJHtjbGFzc05hbWV9YH0gc3R5bGU9e3sgaGVpZ2h0IH19PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWVuZCBqdXN0aWZ5LWJldHdlZW4gaC1mdWxsXCI+XG4gICAgICAgIHtkYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBiYXJIZWlnaHQgPSAoaXRlbS52YWx1ZSAvIG1heFZhbHVlKSAqIGNoYXJ0SGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IGJhckNvbG9yID0gaXRlbS5jb2xvciB8fCBnZXRDb2xvcihpbmRleCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZmxleC0xXCJcbiAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6IGluZGV4IDwgZGF0YS5sZW5ndGggLSAxID8gYmFyU3BhY2luZyA6IDAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgey8qIFZhbHVlIGxhYmVsICovfVxuICAgICAgICAgICAgICB7c2hvd1ZhbHVlcyAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtaW52YXJ5LW5ldXRyYWwgZGFyazp0ZXh0LWdyYXktMzAwIG1iLTEgZm9udC1tZWRpdW1cIj5cbiAgICAgICAgICAgICAgICAgIHtpdGVtLnZhbHVlfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgey8qIEJhciAqL31cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgZmxleCBpdGVtcy1lbmRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B3LWZ1bGwgcm91bmRlZC10ICR7YW5pbWF0ZWQgPyAndHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tNTAwIGVhc2Utb3V0JyA6ICcnfWB9XG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgbGluZWFyLWdyYWRpZW50KHRvIHRvcCwgJHtiYXJDb2xvcn0sICR7YmFyQ29sb3J9ZGQpYFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7LyogU2hpbmUgZWZmZWN0ICovfVxuICAgICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCByb3VuZGVkLXQtc21cIlxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCByZ2JhKDI1NSwyNTUsMjU1LDAuMSkgMCUsIHRyYW5zcGFyZW50IDUwJSknXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHsvKiBMYWJlbCAqL31cbiAgICAgICAgICAgICAge3Nob3dMYWJlbHMgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWludmFyeS1uZXV0cmFsIGRhcms6dGV4dC1ncmF5LTQwMCBtdC0yIHRleHQtY2VudGVyIHRydW5jYXRlIHctZnVsbFwiPlxuICAgICAgICAgICAgICAgICAge2l0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSwgKHByZXZQcm9wcywgbmV4dFByb3BzKSA9PiB7XG4gIC8vIEN1c3RvbSBjb21wYXJpc29uIGZvciBhcnJheSBkYXRhXG4gIGlmIChwcmV2UHJvcHMuZGF0YS5sZW5ndGggIT09IG5leHRQcm9wcy5kYXRhLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgZGF0YUVxdWFsID0gcHJldlByb3BzLmRhdGEuZXZlcnkoKGl0ZW0sIGlkeCkgPT4ge1xuICAgIGNvbnN0IG5leHRJdGVtID0gbmV4dFByb3BzLmRhdGFbaWR4XTtcbiAgICByZXR1cm4gaXRlbS5sYWJlbCA9PT0gbmV4dEl0ZW0ubGFiZWwgJiYgXG4gICAgICAgICAgIGl0ZW0udmFsdWUgPT09IG5leHRJdGVtLnZhbHVlICYmIFxuICAgICAgICAgICBpdGVtLmNvbG9yID09PSBuZXh0SXRlbS5jb2xvcjtcbiAgfSk7XG4gIFxuICByZXR1cm4gKFxuICAgIGRhdGFFcXVhbCAmJlxuICAgIHByZXZQcm9wcy5oZWlnaHQgPT09IG5leHRQcm9wcy5oZWlnaHQgJiZcbiAgICBwcmV2UHJvcHMuc2hvd0xhYmVscyA9PT0gbmV4dFByb3BzLnNob3dMYWJlbHMgJiZcbiAgICBwcmV2UHJvcHMuc2hvd1ZhbHVlcyA9PT0gbmV4dFByb3BzLnNob3dWYWx1ZXMgJiZcbiAgICBwcmV2UHJvcHMuYW5pbWF0ZWQgPT09IG5leHRQcm9wcy5hbmltYXRlZCAmJlxuICAgIHByZXZQcm9wcy5jbGFzc05hbWUgPT09IG5leHRQcm9wcy5jbGFzc05hbWUgJiZcbiAgICBwcmV2UHJvcHMuYmFyU3BhY2luZyA9PT0gbmV4dFByb3BzLmJhclNwYWNpbmdcbiAgKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBCYXJDaGFydDsiXSwibmFtZXMiOlsiQmFyQ2hhcnQiLCJSZWFjdCIsIm1lbW8iLCJwcm9wcyIsImdldENvbG9yIiwidXNlQ2hhcnRUaGVtZSIsImRhdGEiLCJyYXdEYXRhIiwiaGVpZ2h0Iiwic2hvd0xhYmVscyIsInNob3dWYWx1ZXMiLCJhbmltYXRlZCIsImNsYXNzTmFtZSIsImJhclNwYWNpbmciLCJ1c2VNZW1vIiwidmFsaWRhdGlvbk1vbml0b3IiLCJtZWFzdXJlVmFsaWRhdGlvbiIsInNhbml0aXplZFByb3BzIiwic2FuaXRpemVDaGFydFByb3BzIiwic2FuaXRpemVkRGF0YSIsInNhbml0aXplQmFyQ2hhcnREYXRhIiwiZXJyb3IiLCJDaGFydFZhbGlkYXRpb25FcnJvciIsImNvbnNvbGUiLCJsZW5ndGgiLCJkaXYiLCJzdHlsZSIsIm1heFZhbHVlIiwiTWF0aCIsIm1heCIsIm1hcCIsImQiLCJ2YWx1ZSIsImxhYmVsSGVpZ2h0IiwiY2hhcnRIZWlnaHQiLCJpdGVtIiwiaW5kZXgiLCJiYXJIZWlnaHQiLCJiYXJDb2xvciIsImNvbG9yIiwibWFyZ2luUmlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kIiwibGFiZWwiLCJwcmV2UHJvcHMiLCJuZXh0UHJvcHMiLCJkYXRhRXF1YWwiLCJldmVyeSIsImlkeCIsIm5leHRJdGVtIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBcUJhQSxRQUFRO2VBQVJBOztJQXFJYixPQUF3QjtlQUF4Qjs7OzsrREF4SitCOytCQUNEO2lDQU12Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUEsTUFBTUEseUJBQVdDLGNBQUssQ0FBQ0MsSUFBSSxDQUFDLFNBQVNGLFNBQVNHLEtBQW9CO0lBQ3ZFLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdDLElBQUFBLDRCQUFhO0lBRWxDLDhCQUE4QjtJQUM5QixNQUFNLEVBQ0pDLE1BQU1DLE9BQU8sRUFDYkMsU0FBUyxHQUFHLEVBQ1pDLGFBQWEsSUFBSSxFQUNqQkMsYUFBYSxLQUFLLEVBQ2xCQyxXQUFXLElBQUksRUFDZkMsWUFBWSxFQUFFLEVBQ2RDLGFBQWEsQ0FBQyxFQUNmLEdBQUdDLElBQUFBLGNBQU8sRUFBQztRQUNWLE9BQU9DLGtDQUFpQixDQUFDQyxpQkFBaUIsQ0FBQyxZQUFZO1lBQ3JELElBQUk7Z0JBQ0YsTUFBTUMsaUJBQWlCQyxJQUFBQSxtQ0FBa0IsRUFBQ2Y7Z0JBQzFDLE1BQU1nQixnQkFBZ0JDLElBQUFBLHFDQUFvQixFQUFDakIsTUFBTUcsSUFBSTtnQkFFckQsT0FBTztvQkFDTCxHQUFHSCxLQUFLO29CQUNSLEdBQUdjLGNBQWM7b0JBQ2pCWCxNQUFNYTtnQkFDUjtZQUNGLEVBQUUsT0FBT0UsT0FBTztnQkFDZCxJQUFJ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