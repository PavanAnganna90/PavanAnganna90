d3b07766c868bc1ca7a1d98a92f52729
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    LineChart: function() {
        return LineChart;
    },
    default: function() {
        return _default;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _useChartTheme = require("../../hooks/useChartTheme");
const _chartValidation = require("../../lib/chartValidation");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const LineChart = /*#__PURE__*/ _react.default.memo(function LineChart(props) {
    const { getColor } = (0, _useChartTheme.useChartTheme)();
    // Validate and sanitize props
    const { data: rawData, height = 40, color, strokeWidth = 2, showDots = false, animated = true, className = '', colorIndex = 0 } = (0, _react.useMemo)(()=>{
        return _chartValidation.validationMonitor.measureValidation('LineChart', ()=>{
            try {
                const sanitizedProps = (0, _chartValidation.sanitizeChartProps)(props);
                const sanitizedData = (0, _chartValidation.sanitizeLineChartData)(props.data);
                return {
                    ...props,
                    ...sanitizedProps,
                    data: sanitizedData
                };
            } catch (error) {
                if (error instanceof _chartValidation.ChartValidationError) {
                    console.error('LineChart validation error:', error);
                    // Return safe defaults
                    return {
                        ...props,
                        data: [],
                        height: 40,
                        strokeWidth: 2,
                        showDots: false,
                        animated: true,
                        className: '',
                        colorIndex: 0
                    };
                }
                throw error;
            }
        });
    }, [
        props
    ]);
    const data = rawData;
    const chartColor = color || getColor(colorIndex);
    if (!data || data.length === 0) {
        return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
            className: `w-full bg-gray-100 dark:bg-invary-secondary/20 rounded ${className}`,
            style: {
                height
            },
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                className: "flex items-center justify-center h-full text-invary-neutral dark:text-gray-400 text-xs",
                children: "No data"
            })
        });
    }
    const maxValue = Math.max(...data);
    const minValue = Math.min(...data);
    const range = maxValue - minValue || 1; // Prevent division by zero
    // Memoize expensive path calculations
    const { pathData, points } = (0, _react.useMemo)(()=>{
        const width1 = 100; // Use percentage width
        const padding = 2;
        const stepX = (width1 - padding * 2) / (data.length - 1);
        const calculatedPoints = data.map((value, index)=>{
            const x = padding + index * stepX;
            const y = height - padding - (value - minValue) / range * (height - padding * 2);
            return {
                x,
                y,
                coord: `${x},${y}`
            };
        });
        const pathData = `M ${calculatedPoints.map((p)=>p.coord).join(' L ')}`;
        return {
            pathData,
            points: calculatedPoints
        };
    }, [
        data,
        height,
        minValue,
        range
    ]);
    // Create stable gradient ID to prevent re-rendering
    const gradientId = (0, _react.useMemo)(()=>`gradient-${colorIndex}-${chartColor.replace('#', '')}`, [
        colorIndex,
        chartColor
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        className: `w-full ${className}`,
        style: {
            height
        },
        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("svg", {
            width: "100%",
            height: "100%",
            viewBox: `0 0 ${width} ${height}`,
            className: "overflow-visible",
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)("defs", {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("linearGradient", {
                        id: gradientId,
                        x1: "0%",
                        y1: "0%",
                        x2: "0%",
                        y2: "100%",
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("stop", {
                                offset: "0%",
                                stopColor: chartColor,
                                stopOpacity: "0.4"
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("stop", {
                                offset: "100%",
                                stopColor: chartColor,
                                stopOpacity: "0.05"
                            })
                        ]
                    })
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)("path", {
                    d: `${pathData} L ${points[points.length - 1]?.x || 0},${height - 2} L ${points[0]?.x || 0},${height - 2} Z`,
                    fill: `url(#${gradientId})`,
                    className: animated ? 'transition-all duration-300 ease-in-out' : ''
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsx)("path", {
                    d: pathData,
                    fill: "none",
                    stroke: chartColor,
                    strokeWidth: strokeWidth,
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    className: animated ? 'transition-all duration-300 ease-in-out' : ''
                }),
                showDots && points.map((point, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)("circle", {
                        cx: point.x,
                        cy: point.y,
                        r: "2",
                        fill: chartColor,
                        className: animated ? 'transition-all duration-300 ease-in-out' : ''
                    }, index))
            ]
        })
    });
}, (prevProps, nextProps)=>{
    // Custom comparison for array data
    if (prevProps.data.length !== nextProps.data.length) return false;
    const dataEqual = prevProps.data.every((val, idx)=>val === nextProps.data[idx]);
    return dataEqual && prevProps.height === nextProps.height && prevProps.color === nextProps.color && prevProps.strokeWidth === nextProps.strokeWidth && prevProps.showDots === nextProps.showDots && prevProps.animated === nextProps.animated && prevProps.className === nextProps.className && prevProps.colorIndex === nextProps.colorIndex;
});
const _default = LineChart;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXZhbi9EZXNrdG9wL0Rldm9wcy1hcHAtZGV2LWN1cnNvci9mcm9udGVuZC9zcmMvY29tcG9uZW50cy9jaGFydHMvTGluZUNoYXJ0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ2hhcnRUaGVtZSB9IGZyb20gJ0AvaG9va3MvdXNlQ2hhcnRUaGVtZSc7XG5pbXBvcnQgeyBcbiAgc2FuaXRpemVMaW5lQ2hhcnREYXRhLCBcbiAgc2FuaXRpemVDaGFydFByb3BzLCBcbiAgdmFsaWRhdGlvbk1vbml0b3IsXG4gIENoYXJ0VmFsaWRhdGlvbkVycm9yIFxufSBmcm9tICdAL2xpYi9jaGFydFZhbGlkYXRpb24nO1xuXG5pbnRlcmZhY2UgTGluZUNoYXJ0UHJvcHMge1xuICBkYXRhOiBudW1iZXJbXTtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBjb2xvcj86IHN0cmluZztcbiAgc3Ryb2tlV2lkdGg/OiBudW1iZXI7XG4gIHNob3dEb3RzPzogYm9vbGVhbjtcbiAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGNvbG9ySW5kZXg/OiBudW1iZXI7IC8vIEZvciBhdXRvbWF0aWMgdGhlbWUgY29sb3Igc2VsZWN0aW9uXG59XG5cbmV4cG9ydCBjb25zdCBMaW5lQ2hhcnQgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIExpbmVDaGFydChwcm9wczogTGluZUNoYXJ0UHJvcHMpIHtcbiAgY29uc3QgeyBnZXRDb2xvciB9ID0gdXNlQ2hhcnRUaGVtZSgpO1xuICBcbiAgLy8gVmFsaWRhdGUgYW5kIHNhbml0aXplIHByb3BzXG4gIGNvbnN0IHtcbiAgICBkYXRhOiByYXdEYXRhLFxuICAgIGhlaWdodCA9IDQwLFxuICAgIGNvbG9yLFxuICAgIHN0cm9rZVdpZHRoID0gMixcbiAgICBzaG93RG90cyA9IGZhbHNlLFxuICAgIGFuaW1hdGVkID0gdHJ1ZSxcbiAgICBjbGFzc05hbWUgPSAnJyxcbiAgICBjb2xvckluZGV4ID0gMFxuICB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHZhbGlkYXRpb25Nb25pdG9yLm1lYXN1cmVWYWxpZGF0aW9uKCdMaW5lQ2hhcnQnLCAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWRQcm9wcyA9IHNhbml0aXplQ2hhcnRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSBzYW5pdGl6ZUxpbmVDaGFydERhdGEocHJvcHMuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgIC4uLnNhbml0aXplZFByb3BzLFxuICAgICAgICAgIGRhdGE6IHNhbml0aXplZERhdGFcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENoYXJ0VmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTGluZUNoYXJ0IHZhbGlkYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgIC8vIFJldHVybiBzYWZlIGRlZmF1bHRzXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBoZWlnaHQ6IDQwLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzaG93RG90czogZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgICBjb2xvckluZGV4OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3Byb3BzXSk7XG5cbiAgY29uc3QgZGF0YSA9IHJhd0RhdGE7XG4gIGNvbnN0IGNoYXJ0Q29sb3IgPSBjb2xvciB8fCBnZXRDb2xvcihjb2xvckluZGV4KTtcbiAgXG4gIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YHctZnVsbCBiZy1ncmF5LTEwMCBkYXJrOmJnLWludmFyeS1zZWNvbmRhcnkvMjAgcm91bmRlZCAke2NsYXNzTmFtZX1gfSBzdHlsZT17eyBoZWlnaHQgfX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgaC1mdWxsIHRleHQtaW52YXJ5LW5ldXRyYWwgZGFyazp0ZXh0LWdyYXktNDAwIHRleHQteHNcIj5cbiAgICAgICAgICBObyBkYXRhXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1heFZhbHVlID0gTWF0aC5tYXgoLi4uZGF0YSk7XG4gIGNvbnN0IG1pblZhbHVlID0gTWF0aC5taW4oLi4uZGF0YSk7XG4gIGNvbnN0IHJhbmdlID0gbWF4VmFsdWUgLSBtaW5WYWx1ZSB8fCAxOyAvLyBQcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm9cblxuICAvLyBNZW1vaXplIGV4cGVuc2l2ZSBwYXRoIGNhbGN1bGF0aW9uc1xuICBjb25zdCB7IHBhdGhEYXRhLCBwb2ludHMgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHdpZHRoID0gMTAwOyAvLyBVc2UgcGVyY2VudGFnZSB3aWR0aFxuICAgIGNvbnN0IHBhZGRpbmcgPSAyO1xuICAgIGNvbnN0IHN0ZXBYID0gKHdpZHRoIC0gcGFkZGluZyAqIDIpIC8gKGRhdGEubGVuZ3RoIC0gMSk7XG4gICAgXG4gICAgY29uc3QgY2FsY3VsYXRlZFBvaW50cyA9IGRhdGEubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHggPSBwYWRkaW5nICsgaW5kZXggKiBzdGVwWDtcbiAgICAgIGNvbnN0IHkgPSBoZWlnaHQgLSBwYWRkaW5nIC0gKCh2YWx1ZSAtIG1pblZhbHVlKSAvIHJhbmdlKSAqIChoZWlnaHQgLSBwYWRkaW5nICogMik7XG4gICAgICByZXR1cm4geyB4LCB5LCBjb29yZDogYCR7eH0sJHt5fWAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHBhdGhEYXRhID0gYE0gJHtjYWxjdWxhdGVkUG9pbnRzLm1hcChwID0+IHAuY29vcmQpLmpvaW4oJyBMICcpfWA7XG4gICAgXG4gICAgcmV0dXJuIHsgcGF0aERhdGEsIHBvaW50czogY2FsY3VsYXRlZFBvaW50cyB9O1xuICB9LCBbZGF0YSwgaGVpZ2h0LCBtaW5WYWx1ZSwgcmFuZ2VdKTtcblxuICAvLyBDcmVhdGUgc3RhYmxlIGdyYWRpZW50IElEIHRvIHByZXZlbnQgcmUtcmVuZGVyaW5nXG4gIGNvbnN0IGdyYWRpZW50SWQgPSB1c2VNZW1vKCgpID0+IFxuICAgIGBncmFkaWVudC0ke2NvbG9ySW5kZXh9LSR7Y2hhcnRDb2xvci5yZXBsYWNlKCcjJywgJycpfWAsIFxuICAgIFtjb2xvckluZGV4LCBjaGFydENvbG9yXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2B3LWZ1bGwgJHtjbGFzc05hbWV9YH0gc3R5bGU9e3sgaGVpZ2h0IH19PlxuICAgICAgPHN2ZyBcbiAgICAgICAgd2lkdGg9XCIxMDAlXCIgXG4gICAgICAgIGhlaWdodD1cIjEwMCVcIiBcbiAgICAgICAgdmlld0JveD17YDAgMCAke3dpZHRofSAke2hlaWdodH1gfSBcbiAgICAgICAgY2xhc3NOYW1lPVwib3ZlcmZsb3ctdmlzaWJsZVwiXG4gICAgICA+XG4gICAgICAgIDxkZWZzPlxuICAgICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD17Z3JhZGllbnRJZH0geDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCI+XG4gICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3BDb2xvcj17Y2hhcnRDb2xvcn0gc3RvcE9wYWNpdHk9XCIwLjRcIiAvPlxuICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3BDb2xvcj17Y2hhcnRDb2xvcn0gc3RvcE9wYWNpdHk9XCIwLjA1XCIgLz5cbiAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICA8L2RlZnM+XG4gICAgICAgIFxuICAgICAgICB7LyogRmlsbCBhcmVhICovfVxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9e2Ake3BhdGhEYXRhfSBMICR7cG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXT8ueCB8fCAwfSwke2hlaWdodCAtIDJ9IEwgJHtwb2ludHNbMF0/LnggfHwgMH0sJHtoZWlnaHQgLSAyfSBaYH1cbiAgICAgICAgICBmaWxsPXtgdXJsKCMke2dyYWRpZW50SWR9KWB9XG4gICAgICAgICAgY2xhc3NOYW1lPXthbmltYXRlZCA/ICd0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQnIDogJyd9XG4gICAgICAgIC8+XG4gICAgICAgIFxuICAgICAgICB7LyogTGluZSAqL31cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPXtwYXRoRGF0YX1cbiAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgc3Ryb2tlPXtjaGFydENvbG9yfVxuICAgICAgICAgIHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH1cbiAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgIGNsYXNzTmFtZT17YW5pbWF0ZWQgPyAndHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0JyA6ICcnfVxuICAgICAgICAvPlxuICAgICAgICBcbiAgICAgICAgey8qIERvdHMgKi99XG4gICAgICAgIHtzaG93RG90cyAmJiBwb2ludHMubWFwKChwb2ludCwgaW5kZXgpID0+IChcbiAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgY3g9e3BvaW50Lnh9XG4gICAgICAgICAgICBjeT17cG9pbnQueX1cbiAgICAgICAgICAgIHI9XCIyXCJcbiAgICAgICAgICAgIGZpbGw9e2NoYXJ0Q29sb3J9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2FuaW1hdGVkID8gJ3RyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCcgOiAnJ31cbiAgICAgICAgICAvPlxuICAgICAgICApKX1cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApO1xufSwgKHByZXZQcm9wcywgbmV4dFByb3BzKSA9PiB7XG4gIC8vIEN1c3RvbSBjb21wYXJpc29uIGZvciBhcnJheSBkYXRhXG4gIGlmIChwcmV2UHJvcHMuZGF0YS5sZW5ndGggIT09IG5leHRQcm9wcy5kYXRhLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgZGF0YUVxdWFsID0gcHJldlByb3BzLmRhdGEuZXZlcnkoKHZhbCwgaWR4KSA9PiB2YWwgPT09IG5leHRQcm9wcy5kYXRhW2lkeF0pO1xuICBcbiAgcmV0dXJuIChcbiAgICBkYXRhRXF1YWwgJiZcbiAgICBwcmV2UHJvcHMuaGVpZ2h0ID09PSBuZXh0UHJvcHMuaGVpZ2h0ICYmXG4gICAgcHJldlByb3BzLmNvbG9yID09PSBuZXh0UHJvcHMuY29sb3IgJiZcbiAgICBwcmV2UHJvcHMuc3Ryb2tlV2lkdGggPT09IG5leHRQcm9wcy5zdHJva2VXaWR0aCAmJlxuICAgIHByZXZQcm9wcy5zaG93RG90cyA9PT0gbmV4dFByb3BzLnNob3dEb3RzICYmXG4gICAgcHJldlByb3BzLmFuaW1hdGVkID09PSBuZXh0UHJvcHMuYW5pbWF0ZWQgJiZcbiAgICBwcmV2UHJvcHMuY2xhc3NOYW1lID09PSBuZXh0UHJvcHMuY2xhc3NOYW1lICYmXG4gICAgcHJldlByb3BzLmNvbG9ySW5kZXggPT09IG5leHRQcm9wcy5jb2xvckluZGV4XG4gICk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgTGluZUNoYXJ0OyJdLCJuYW1lcyI6WyJMaW5lQ2hhcnQiLCJSZWFjdCIsIm1lbW8iLCJwcm9wcyIsImdldENvbG9yIiwidXNlQ2hhcnRUaGVtZSIsImRhdGEiLCJyYXdEYXRhIiwiaGVpZ2h0IiwiY29sb3IiLCJzdHJva2VXaWR0aCIsInNob3dEb3RzIiwiYW5pbWF0ZWQiLCJjbGFzc05hbWUiLCJjb2xvckluZGV4IiwidXNlTWVtbyIsInZhbGlkYXRpb25Nb25pdG9yIiwibWVhc3VyZVZhbGlkYXRpb24iLCJzYW5pdGl6ZWRQcm9wcyIsInNhbml0aXplQ2hhcnRQcm9wcyIsInNhbml0aXplZERhdGEiLCJzYW5pdGl6ZUxpbmVDaGFydERhdGEiLCJlcnJvciIsIkNoYXJ0VmFsaWRhdGlvbkVycm9yIiwiY29uc29sZSIsImNoYXJ0Q29sb3IiLCJsZW5ndGgiLCJkaXYiLCJzdHlsZSIsIm1heFZhbHVlIiwiTWF0aCIsIm1heCIsIm1pblZhbHVlIiwibWluIiwicmFuZ2UiLCJwYXRoRGF0YSIsInBvaW50cyIsIndpZHRoIiwicGFkZGluZyIsInN0ZXBYIiwiY2FsY3VsYXRlZFBvaW50cyIsIm1hcCIsInZhbHVlIiwiaW5kZXgiLCJ4IiwieSIsImNvb3JkIiwicCIsImpvaW4iLCJncmFkaWVudElkIiwicmVwbGFjZSIsInN2ZyIsInZpZXdCb3giLCJkZWZzIiwibGluZWFyR3JhZGllbnQiLCJpZCIsIngxIiwieTEiLCJ4MiIsInkyIiwic3RvcCIsIm9mZnNldCIsInN0b3BDb2xvciIsInN0b3BPcGFjaXR5IiwicGF0aCIsImQiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwicG9pbnQiLCJjaXJjbGUiLCJjeCIsImN5IiwiciIsInByZXZQcm9wcyIsIm5leHRQcm9wcyIsImRhdGFFcXVhbCIsImV2ZXJ5IiwidmFsIiwiaWR4Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBc0JhQSxTQUFT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