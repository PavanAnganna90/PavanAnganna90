import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';

// User and authentication interfaces
export interface User {
  id: number;
  email: string;
  name: string;
  avatar_url?: string;
  github_username?: string;
  role: 'admin' | 'manager' | 'developer' | 'viewer';
  teams: UserTeam[];
  permissions: string[];
  last_login?: string;
  created_at: string;
}

export interface UserTeam {
  id: number;
  name: string;
  role: 'owner' | 'admin' | 'member' | 'viewer';
  permissions: string[];
}

export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  token: string | null;
}

export interface AuthContextType extends AuthState {
  login: (email: string, password: string, rememberMe?: boolean) => Promise<void>;
  loginWithGitHub: (code: string, state: string) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
  updateUser: (userData: Partial<User>) => void;
  hasPermission: (permission: string, teamId?: number) => boolean;
  hasRole: (role: string, teamId?: number) => boolean;
  switchTeam: (teamId: number) => void;
  currentTeam: UserTeam | null;
}

// Create context
export const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Custom hook to use auth context
export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Auth hook implementation
export function useAuthState(): AuthContextType {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isLoading: true,
    token: null
  });
  const [currentTeam, setCurrentTeam] = useState<UserTeam | null>(null);
  const router = useRouter();

  // Initialize auth state on mount
  useEffect(() => {
    initializeAuth();
  }, []);

  // Update current team when user changes
  useEffect(() => {
    if (authState.user && authState.user.teams.length > 0) {
      const savedTeamId = localStorage.getItem('current_team_id');
      const team = savedTeamId 
        ? authState.user.teams.find(t => t.id === parseInt(savedTeamId))
        : authState.user.teams[0];
      setCurrentTeam(team || authState.user.teams[0]);
    } else {
      setCurrentTeam(null);
    }
  }, [authState.user]);

  const initializeAuth = async () => {
    try {
      setAuthState(prev => ({ ...prev, isLoading: true }));

      // Check for stored token
      const token = localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token');
      
      if (!token) {
        setAuthState(prev => ({ ...prev, isLoading: false }));
        return;
      }

      // Validate token and get user data
      const userData = await validateToken(token);
      
      if (userData) {
        setAuthState({
          user: userData,
          isAuthenticated: true,
          isLoading: false,
          token
        });
      } else {
        // Token is invalid, clear it
        clearAuthData();
        setAuthState({
          user: null,
          isAuthenticated: false,
          isLoading: false,
          token: null
        });
      }
    } catch (error) {
      console.error('Auth initialization error:', error);
      clearAuthData();
      setAuthState({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        token: null
      });
    }
  };

  const validateToken = async (token: string): Promise<User | null> => {
    try {
      const response = await fetch('/api/v1/auth/me', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error('Token validation failed');
      }

      return await response.json();
    } catch (error) {
      console.error('Token validation error:', error);
      return null;
    }
  };

  const login = async (email: string, password: string, rememberMe: boolean = false): Promise<void> => {
    try {
      const response = await fetch('/api/v1/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ email, password })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'Login failed');
      }

      const data = await response.json();
      
      // Store token and user data
      const storage = rememberMe ? localStorage : sessionStorage;
      storage.setItem('auth_token', data.access_token);
      
      setAuthState({
        user: data.user,
        isAuthenticated: true,
        isLoading: false,
        token: data.access_token
      });

    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const loginWithGitHub = async (code: string, state: string): Promise<void> => {
    try {
      const response = await fetch('/api/v1/auth/github/callback', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ code, state })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'GitHub authentication failed');
      }

      const data = await response.json();
      
      // Store token and user data
      localStorage.setItem('auth_token', data.access_token);
      
      setAuthState({
        user: data.user,
        isAuthenticated: true,
        isLoading: false,
        token: data.access_token
      });

    } catch (error) {
      console.error('GitHub login error:', error);
      throw error;
    }
  };

  const logout = () => {
    try {
      // Call logout endpoint to invalidate token on server
      if (authState.token) {
        fetch('/api/v1/auth/logout', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authState.token}`,
            'Content-Type': 'application/json'
          }
        }).catch(console.error); // Don't wait for response
      }
    } catch (error) {
      console.error('Logout API error:', error);
    } finally {
      // Clear local state regardless of API call result
      clearAuthData();
      setAuthState({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        token: null
      });
      setCurrentTeam(null);
      
      // Redirect to login page
      router.push('/auth/login');
    }
  };

  const refreshToken = async (): Promise<void> => {
    try {
      if (!authState.token) {
        throw new Error('No token to refresh');
      }

      const response = await fetch('/api/v1/auth/refresh', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${authState.token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error('Token refresh failed');
      }

      const data = await response.json();
      
      // Update stored token
      const storage = localStorage.getItem('auth_token') ? localStorage : sessionStorage;
      storage.setItem('auth_token', data.access_token);
      
      setAuthState(prev => ({
        ...prev,
        token: data.access_token,
        user: data.user || prev.user
      }));

    } catch (error) {
      console.error('Token refresh error:', error);
      logout(); // Force logout on refresh failure
      throw error;
    }
  };

  const updateUser = (userData: Partial<User>) => {
    setAuthState(prev => ({
      ...prev,
      user: prev.user ? { ...prev.user, ...userData } : null
    }));
  };

  const hasPermission = (permission: string, teamId?: number): boolean => {
    if (!authState.user) return false;

    // Check global permissions first
    if (authState.user.permissions.includes(permission)) {
      return true;
    }

    // Check team-specific permissions
    if (teamId) {
      const team = authState.user.teams.find(t => t.id === teamId);
      return team ? team.permissions.includes(permission) : false;
    }

    // Check current team permissions
    if (currentTeam) {
      return currentTeam.permissions.includes(permission);
    }

    return false;
  };

  const hasRole = (role: string, teamId?: number): boolean => {
    if (!authState.user) return false;

    // Check global role
    if (authState.user.role === role) {
      return true;
    }

    // Check team-specific role
    if (teamId) {
      const team = authState.user.teams.find(t => t.id === teamId);
      return team ? team.role === role : false;
    }

    // Check current team role
    if (currentTeam) {
      return currentTeam.role === role;
    }

    return false;
  };

  const switchTeam = (teamId: number) => {
    if (!authState.user) return;

    const team = authState.user.teams.find(t => t.id === teamId);
    if (team) {
      setCurrentTeam(team);
      localStorage.setItem('current_team_id', teamId.toString());
    }
  };

  const clearAuthData = () => {
    localStorage.removeItem('auth_token');
    localStorage.removeItem('current_team_id');
    sessionStorage.removeItem('auth_token');
  };

  return {
    ...authState,
    login,
    loginWithGitHub,
    logout,
    refreshToken,
    updateUser,
    hasPermission,
    hasRole,
    switchTeam,
    currentTeam
  };
}

// Auth provider component
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const auth = useAuthState();

  return (
    <AuthContext.Provider value={auth}>
      {children}
    </AuthContext.Provider>
  );
}

// Higher-order component for route protection
export function withAuth<T extends object>(
  WrappedComponent: React.ComponentType<T>,
  options: {
    requireAuth?: boolean;
    requiredPermissions?: string[];
    requiredRole?: string;
    redirectTo?: string;
  } = {}
) {
  const {
    requireAuth = true,
    requiredPermissions = [],
    requiredRole,
    redirectTo = '/auth/login'
  } = options;

  return function AuthenticatedComponent(props: T) {
    const { isAuthenticated, isLoading, hasPermission, hasRole, user } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (isLoading) return;

      if (requireAuth && !isAuthenticated) {
        router.push(redirectTo);
        return;
      }

      if (isAuthenticated && user) {
        // Check required permissions
        if (requiredPermissions.length > 0) {
          const hasAllPermissions = requiredPermissions.every(permission => 
            hasPermission(permission)
          );
          
          if (!hasAllPermissions) {
            router.push('/unauthorized');
            return;
          }
        }

        // Check required role
        if (requiredRole && !hasRole(requiredRole)) {
          router.push('/unauthorized');
          return;
        }
      }
    }, [isAuthenticated, isLoading, user, router]);

    if (isLoading) {
      return (
        <div className="min-h-screen bg-kassow-dark flex items-center justify-center">
          <div className="flex flex-col items-center">
            <svg className="animate-spin h-8 w-8 text-kassow-accent mb-4" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <div className="text-kassow-light">Loading...</div>
          </div>
        </div>
      );
    }

    if (requireAuth && !isAuthenticated) {
      return null; // Will be redirected
    }

    return <WrappedComponent {...props} />;
  };
}